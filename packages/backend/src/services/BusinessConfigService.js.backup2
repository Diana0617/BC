const { Op } = require('sequelize');
const Business = require('../models/Business');
// const BusinessRules = require('../models/BusinessRules'); // Deprecated - replaced with BusinessRule
const SpecialistProfile = require('../models/SpecialistProfile');
const Schedule = require('../models/Schedule');
const TimeSlot = require('../models/TimeSlot');
const BusinessPaymentConfig = require('../models/BusinessPaymentConfig');
const User = require('../models/User');
const Service = require('../models/Service');
// Modelos para inventario y proveedores
const Product = require('../models/Product');
const InventoryMovement = require('../models/InventoryMovement');
const Supplier = require('../models/Supplier');
const SupplierContact = require('../models/SupplierContact');
const PurchaseOrder = require('../models/PurchaseOrder');
const SupplierInvoice = require('../models/SupplierInvoice');
const SupplierEvaluation = require('../models/SupplierEvaluation');
const SupplierCatalogItem = require('../models/SupplierCatalogItem');
const { sequelize } = require('../config/database');

class BusinessConfigService {
  
  // ==================== GESTIÓN DE REGLAS DEL NEGOCIO ====================
  
  // TEMPORARILY DISABLED - BusinessRules methods under refactoring
  async getBusinessRules(businessId) {
    throw new Error('BusinessRules functionality temporarily unavailable - system under refactoring');
    /*
    try {
      let rules = await BusinessRules.findOne({
        where: { businessId }
      });

      // Si no existen reglas, crear las predeterminadas
      if (!rules) {
        rules = await BusinessRules.create({
          businessId,
          // Los valores por defecto están definidos en el modelo
        });
      }

      return rules;
    } catch (error) {
      throw new Error(`Error al obtener reglas del negocio: ${error.message}`);
    }
    */
  }

  async updateBusinessRules(businessId, rulesData) {
    throw new Error('BusinessRules functionality temporarily unavailable - system under refactoring');
    /*
    try {
      const [rules, created] = await BusinessRules.findOrCreate({
        where: { businessId },
        defaults: { businessId, ...rulesData }
      });

      if (!created) {
        await rules.update(rulesData);
      }

      return rules;
    } catch (error) {
      throw new Error(`Error al actualizar reglas del negocio: ${error.message}`);
    }
    */
  }
  }

  // ==================== GESTIÓN DE ESPECIALISTAS ====================

  async getSpecialists(businessId, filters = {}) {
    try {
      const whereClause = { businessId };
      
      if (filters.isActive !== undefined) {
        whereClause.isActive = filters.isActive;
      }
      
      if (filters.status) {
        whereClause.status = filters.status;
      }

      if (filters.specialization) {
        whereClause.specialization = {
          [Op.iLike]: `%${filters.specialization}%`
        };
      }

      const specialists = await SpecialistProfile.findAll({
        where: whereClause,
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'firstName', 'lastName', 'email', 'phone', 'avatar', 'status'],
            where: { role: 'SPECIALIST' }
          }
        ],
        order: [['createdAt', 'DESC']]
      });

      return specialists;
    } catch (error) {
      throw new Error(`Error al obtener especialistas: ${error.message}`);
    }
  }

  async createSpecialist(businessId, userData, profileData) {
    try {
      // Crear el usuario especialista
      const user = await User.create({
        ...userData,
        role: 'SPECIALIST',
        businessId
      });

      // Crear el perfil del especialista
      const profile = await SpecialistProfile.create({
        userId: user.id,
        businessId,
        ...profileData
      });

      // Crear horario por defecto para el especialista
      await this.createDefaultScheduleForSpecialist(businessId, user.id);

      return {
        user,
        profile
      };
    } catch (error) {
      throw new Error(`Error al crear especialista: ${error.message}`);
    }
  }

  async updateSpecialistProfile(profileId, profileData) {
    try {
      const profile = await SpecialistProfile.findByPk(profileId);
      if (!profile) {
        throw new Error('Perfil de especialista no encontrado');
      }

      await profile.update(profileData);
      return profile;
    } catch (error) {
      throw new Error(`Error al actualizar perfil de especialista: ${error.message}`);
    }
  }

  async deleteSpecialist(profileId) {
    try {
      const profile = await SpecialistProfile.findByPk(profileId, {
        include: [{ model: User, as: 'user' }]
      });
      
      if (!profile) {
        throw new Error('Especialista no encontrado');
      }

      // Verificar si tiene citas pendientes
      const hasPendingAppointments = await this.hasActivAppointments(profile.userId);
      if (hasPendingAppointments) {
        // En lugar de eliminar, desactivar
        await profile.update({ 
          status: 'INACTIVE', 
          isActive: false 
        });
        await profile.user.update({ status: 'INACTIVE' });
        
        return { deleted: false, deactivated: true };
      }

      // Eliminar horarios y slots asociados
      await this.deleteSpecialistSchedulesAndSlots(profile.userId);
      
      // Eliminar perfil y usuario
      await profile.destroy();
      await profile.user.destroy();

      return { deleted: true, deactivated: false };
    } catch (error) {
      throw new Error(`Error al eliminar especialista: ${error.message}`);
    }
  }

  // ==================== GESTIÓN DE HORARIOS ====================

  async getSchedules(businessId, specialistId = null) {
    try {
      const whereClause = { businessId };
      if (specialistId) {
        whereClause.specialistId = specialistId;
      }

      const schedules = await Schedule.findAll({
        where: whereClause,
        include: [
          {
            model: User,
            as: 'specialist',
            attributes: ['id', 'firstName', 'lastName'],
            required: false
          },
          {
            model: User,
            as: 'createdByUser',
            attributes: ['id', 'firstName', 'lastName'],
            required: false
          }
        ],
        order: [
          ['isDefault', 'DESC'],
          ['priority', 'DESC'],
          ['createdAt', 'DESC']
        ]
      });

      return schedules;
    } catch (error) {
      throw new Error(`Error al obtener horarios: ${error.message}`);
    }
  }

  async createSchedule(businessId, scheduleData, createdBy) {
    try {
      // Si es el horario por defecto, desactivar otros horarios por defecto
      if (scheduleData.isDefault) {
        await this.deactivateOtherDefaultSchedules(
          businessId, 
          scheduleData.specialistId
        );
      }

      const schedule = await Schedule.create({
        businessId,
        ...scheduleData,
        createdBy
      });

      // Generar slots de tiempo para este horario
      await this.generateTimeSlotsForSchedule(schedule);

      return schedule;
    } catch (error) {
      throw new Error(`Error al crear horario: ${error.message}`);
    }
  }

  async updateSchedule(scheduleId, scheduleData, updatedBy) {
    try {
      const schedule = await Schedule.findByPk(scheduleId);
      if (!schedule) {
        throw new Error('Horario no encontrado');
      }

      // Si se está marcando como por defecto, desactivar otros
      if (scheduleData.isDefault && !schedule.isDefault) {
        await this.deactivateOtherDefaultSchedules(
          schedule.businessId, 
          schedule.specialistId
        );
      }

      await schedule.update({
        ...scheduleData,
        updatedBy
      });

      // Regenerar slots si cambió la configuración
      if (scheduleData.weeklySchedule || scheduleData.slotDuration) {
        await this.regenerateTimeSlotsForSchedule(schedule);
      }

      return schedule;
    } catch (error) {
      throw new Error(`Error al actualizar horario: ${error.message}`);
    }
  }

  async deleteSchedule(scheduleId) {
    try {
      const schedule = await Schedule.findByPk(scheduleId);
      if (!schedule) {
        throw new Error('Horario no encontrado');
      }

      // Verificar si es el horario por defecto
      if (schedule.isDefault) {
        throw new Error('No se puede eliminar el horario por defecto');
      }

      // Eliminar slots de tiempo asociados
      await TimeSlot.destroy({
        where: { scheduleId }
      });

      await schedule.destroy();
      return true;
    } catch (error) {
      throw new Error(`Error al eliminar horario: ${error.message}`);
    }
  }

  // ==================== GESTIÓN DE SLOTS DE TIEMPO ====================

  async getAvailableSlots(businessId, specialistId, date, serviceId = null) {
    try {
      const whereClause = {
        businessId,
        specialistId,
        date,
        status: 'AVAILABLE'
      };

      if (serviceId) {
        // Validar que el slot sea compatible con la duración del servicio
        const service = await Service.findByPk(serviceId);
        if (service) {
          whereClause.duration = { [Op.gte]: service.duration };
        }
      }

      const slots = await TimeSlot.findAll({
        where: whereClause,
        order: [['startTime', 'ASC']]
      });

      return slots;
    } catch (error) {
      throw new Error(`Error al obtener slots disponibles: ${error.message}`);
    }
  }

  async blockSlot(slotId, reason, blockedBy) {
    try {
      const slot = await TimeSlot.findByPk(slotId);
      if (!slot) {
        throw new Error('Slot no encontrado');
      }

      if (slot.status !== 'AVAILABLE') {
        throw new Error('El slot no está disponible para bloquear');
      }

      await slot.update({
        status: 'BLOCKED',
        blockReason: reason,
        lastModifiedBy: blockedBy
      });

      return slot;
    } catch (error) {
      throw new Error(`Error al bloquear slot: ${error.message}`);
    }
  }

  async unblockSlot(slotId, unblockedBy) {
    try {
      const slot = await TimeSlot.findByPk(slotId);
      if (!slot) {
        throw new Error('Slot no encontrado');
      }

      await slot.update({
        status: 'AVAILABLE',
        blockReason: null,
        lastModifiedBy: unblockedBy
      });

      return slot;
    } catch (error) {
      throw new Error(`Error al desbloquear slot: ${error.message}`);
    }
  }

  // ==================== GESTIÓN DE CONFIGURACIÓN DE PAGOS ====================

  async getPaymentConfig(businessId) {
    try {
      const config = await BusinessPaymentConfig.findOne({
        where: { businessId }
      });

      if (!config) {
        // Crear configuración por defecto
        return await BusinessPaymentConfig.create({
          businessId,
          // Los valores por defecto están en el modelo
        });
      }

      return config;
    } catch (error) {
      throw new Error(`Error al obtener configuración de pagos: ${error.message}`);
    }
  }

  async updatePaymentConfig(businessId, configData, updatedBy) {
    try {
      const [config, created] = await BusinessPaymentConfig.findOrCreate({
        where: { businessId },
        defaults: { businessId, ...configData }
      });

      if (!created) {
        await config.update({
          ...configData,
          activatedBy: updatedBy,
          activatedAt: configData.isActive ? new Date() : null
        });
      }

      return config;
    } catch (error) {
      throw new Error(`Error al actualizar configuración de pagos: ${error.message}`);
    }
  }

  async testPaymentConfig(businessId) {
    try {
      const config = await BusinessPaymentConfig.findOne({
        where: { businessId }
      });

      if (!config) {
        throw new Error('Configuración de pagos no encontrada');
      }

      // Implementar prueba según el proveedor
      let testResult;
      switch (config.provider) {
        case 'WOMPI':
          testResult = await this.testWompiConfig(config);
          break;
        case 'STRIPE':
          testResult = await this.testStripeConfig(config);
          break;
        default:
          throw new Error(`Proveedor ${config.provider} no soportado`);
      }

      // Actualizar resultado de la prueba
      await config.update({
        lastTestDate: new Date(),
        lastTestResult: testResult
      });

      return testResult;
    } catch (error) {
      throw new Error(`Error al probar configuración de pagos: ${error.message}`);
    }
  }

  // ==================== MÉTODOS AUXILIARES ====================

  async createDefaultScheduleForSpecialist(businessId, specialistId) {
    try {
      // TEMPORARILY DISABLED - BusinessRules method unavailable
      throw new Error('createDefaultScheduleForSpecialist temporarily unavailable - BusinessRules system under refactoring');
      
      /*
      // Obtener horario del negocio como referencia
      const businessRules = await this.getBusinessRules(businessId);
      
      const schedule = await Schedule.create({
        businessId,
        specialistId,
        type: 'SPECIALIST_CUSTOM',
        name: 'Horario por defecto',
        isDefault: true,
        isActive: true,
        weeklySchedule: businessRules.workingHours,
        createdBy: specialistId
      });

      await this.generateTimeSlotsForSchedule(schedule);
      return schedule;
      */
    } catch (error) {
      console.error('Error creando horario por defecto:', error);
    }
  }

  async deactivateOtherDefaultSchedules(businessId, specialistId) {
    const whereClause = {
      businessId,
      isDefault: true,
      isActive: true
    };

    if (specialistId) {
      whereClause.specialistId = specialistId;
    } else {
      whereClause.specialistId = null;
    }

    await Schedule.update(
      { isDefault: false },
      { where: whereClause }
    );
  }

  async generateTimeSlotsForSchedule(schedule) {
    try {
      const { weeklySchedule, slotDuration, bufferTime } = schedule;
      const startDate = new Date();
      const endDate = new Date();
      endDate.setDate(endDate.getDate() + 30); // Generar para 30 días

      // Eliminar slots existentes para este horario
      await TimeSlot.destroy({
        where: { scheduleId: schedule.id }
      });

      const slotsToCreate = [];
      
      for (let currentDate = new Date(startDate); currentDate <= endDate; currentDate.setDate(currentDate.getDate() + 1)) {
        const dayName = this.getDayName(currentDate);
        const daySchedule = weeklySchedule[dayName];
        
        if (!daySchedule?.enabled || !daySchedule.shifts?.length) {
          continue;
        }

        for (const shift of daySchedule.shifts) {
          const slots = this.generateSlotsForShift(
            currentDate,
            shift,
            slotDuration,
            bufferTime,
            schedule
          );
          slotsToCreate.push(...slots);
        }
      }

      if (slotsToCreate.length > 0) {
        await TimeSlot.bulkCreate(slotsToCreate);
      }

      return slotsToCreate.length;
    } catch (error) {
      console.error('Error generando slots:', error);
      throw error;
    }
  }

  generateSlotsForShift(date, shift, slotDuration, bufferTime, schedule) {
    const slots = [];
    const dateStr = date.toISOString().split('T')[0];
    
    const startTime = new Date(`${dateStr}T${shift.start}:00`);
    const endTime = new Date(`${dateStr}T${shift.end}:00`);
    
    // Crear break si existe
    let breakStart = null;
    let breakEnd = null;
    if (shift.breakStart && shift.breakEnd) {
      breakStart = new Date(`${dateStr}T${shift.breakStart}:00`);
      breakEnd = new Date(`${dateStr}T${shift.breakEnd}:00`);
    }

    let currentTime = new Date(startTime);
    
    while (currentTime < endTime) {
      const slotEnd = new Date(currentTime.getTime() + (slotDuration * 60000));
      
      if (slotEnd > endTime) break;

      // Verificar si está en horario de break
      const isBreakTime = breakStart && breakEnd && 
        currentTime >= breakStart && currentTime < breakEnd;

      slots.push({
        businessId: schedule.businessId,
        specialistId: schedule.specialistId,
        scheduleId: schedule.id,
        date: dateStr,
        startTime: currentTime.toTimeString().substring(0, 8),
        endTime: slotEnd.toTimeString().substring(0, 8),
        startDateTime: new Date(currentTime),
        endDateTime: new Date(slotEnd),
        status: isBreakTime ? 'BREAK' : 'AVAILABLE',
        type: isBreakTime ? 'BREAK' : 'REGULAR',
        duration: slotDuration,
        generatedAt: new Date()
      });

      currentTime = new Date(slotEnd.getTime() + (bufferTime * 60000));
    }

    return slots;
  }

  getDayName(date) {
    const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    return days[date.getDay()];
  }

  async hasActivAppointments(specialistId) {
    // Esta función se implementaría para verificar citas activas
    // Por ahora retorna false
    return false;
  }

  async deleteSpecialistSchedulesAndSlots(specialistId) {
    await TimeSlot.destroy({
      where: { specialistId }
    });
    await Schedule.destroy({
      where: { specialistId }
    });
  }

  async regenerateTimeSlotsForSchedule(schedule) {
    await this.generateTimeSlotsForSchedule(schedule);
  }

  async testWompiConfig(config) {
    // Implementar prueba de configuración de Wompi
    return {
      success: true,
      message: 'Configuración de Wompi válida',
      provider: 'WOMPI',
      testMode: config.testMode
    };
  }

  async testStripeConfig(config) {
    // Implementar prueba de configuración de Stripe
    return {
      success: true,
      message: 'Configuración de Stripe válida',
      provider: 'STRIPE',
      testMode: config.testMode
    };
  }

  // ==================== GESTIÓN DE SERVICIOS ====================

  /**
   * Obtener servicios del negocio con filtros
   */
  async getServices(businessId, filters = {}) {
    try {
      const whereClause = { businessId };
      
      // Aplicar filtros
      if (typeof filters.isActive === 'boolean') {
        whereClause.isActive = filters.isActive;
      }
      
      if (filters.category) {
        whereClause.category = filters.category;
      }
      
      if (filters.search) {
        whereClause[Op.or] = [
          { name: { [Op.iLike]: `%${filters.search}%` } },
          { description: { [Op.iLike]: `%${filters.search}%` } }
        ];
      }

      // Configurar ordenamiento
      const order = [];
      if (filters.sortBy) {
        const sortOrder = filters.sortOrder || 'asc';
        order.push([filters.sortBy, sortOrder.toUpperCase()]);
      } else {
        order.push(['name', 'ASC']);
      }

      // Configurar paginación
      const limit = filters.limit ? parseInt(filters.limit) : 50;
      const page = filters.page ? parseInt(filters.page) : 1;
      const offset = (page - 1) * limit;

      const { count, rows: services } = await Service.findAndCountAll({
        where: whereClause,
        order,
        limit,
        offset,
        include: [
          {
            model: Business,
            as: 'business',
            attributes: ['id', 'name', 'subdomain']
          }
        ]
      });

      return {
        services,
        pagination: {
          total: count,
          page,
          pages: Math.ceil(count / limit),
          limit
        }
      };
    } catch (error) {
      throw new Error(`Error al obtener servicios: ${error.message}`);
    }
  }

  /**
   * Obtener servicio específico por ID
   */
  async getService(serviceId, businessId = null) {
    try {
      const whereClause = { id: serviceId };
      if (businessId) {
        whereClause.businessId = businessId;
      }

      const service = await Service.findOne({
        where: whereClause,
        include: [
          {
            model: Business,
            as: 'business',
            attributes: ['id', 'name', 'subdomain']
          }
        ]
      });

      if (!service) {
        throw new Error('Servicio no encontrado');
      }

      return service;
    } catch (error) {
      throw new Error(`Error al obtener servicio: ${error.message}`);
    }
  }

  /**
   * Crear nuevo servicio
   */
  async createService(businessId, serviceData) {
    try {
      const service = await Service.create({
        ...serviceData,
        businessId
      });

      return await this.getService(service.id);
    } catch (error) {
      throw new Error(`Error al crear servicio: ${error.message}`);
    }
  }

  /**
   * Actualizar servicio existente
   */
  async updateService(serviceId, serviceData, businessId = null) {
    try {
      const whereClause = { id: serviceId };
      if (businessId) {
        whereClause.businessId = businessId;
      }

      const service = await Service.findOne({ where: whereClause });
      
      if (!service) {
        throw new Error('Servicio no encontrado');
      }

      await service.update(serviceData);
      return await this.getService(serviceId);
    } catch (error) {
      throw new Error(`Error al actualizar servicio: ${error.message}`);
    }
  }

  /**
   * Eliminar servicio
   */
  async deleteService(serviceId, businessId = null) {
    try {
      const whereClause = { id: serviceId };
      if (businessId) {
        whereClause.businessId = businessId;
      }

      const service = await Service.findOne({ where: whereClause });
      
      if (!service) {
        throw new Error('Servicio no encontrado');
      }

      await service.destroy();
      return { success: true, message: 'Servicio eliminado exitosamente' };
    } catch (error) {
      throw new Error(`Error al eliminar servicio: ${error.message}`);
    }
  }

  /**
   * Activar/Desactivar servicio
   */
  async toggleServiceStatus(serviceId, isActive, businessId = null) {
    try {
      const whereClause = { id: serviceId };
      if (businessId) {
        whereClause.businessId = businessId;
      }

      const service = await Service.findOne({ where: whereClause });
      
      if (!service) {
        throw new Error('Servicio no encontrado');
      }

      await service.update({ isActive });
      return await this.getService(serviceId);
    } catch (error) {
      throw new Error(`Error al cambiar estado del servicio: ${error.message}`);
    }
  }

  /**
   * Obtener categorías de servicios del negocio
   */
  async getServiceCategories(businessId) {
    try {
      const categories = await Service.findAll({
        where: { 
          businessId,
          category: { [Op.ne]: null }
        },
        attributes: [
          'category',
          [Service.sequelize.fn('COUNT', Service.sequelize.col('id')), 'count'],
          [Service.sequelize.fn('AVG', Service.sequelize.col('price')), 'avgPrice'],
          [Service.sequelize.fn('SUM', Service.sequelize.literal('CASE WHEN "isActive" = true THEN 1 ELSE 0 END')), 'activeCount']
        ],
        group: ['category'],
        order: [['category', 'ASC']]
      });

      return categories.map(cat => ({
        name: cat.category,
        count: parseInt(cat.dataValues.count),
        activeCount: parseInt(cat.dataValues.activeCount),
        avgPrice: parseFloat(cat.dataValues.avgPrice) || 0
      }));
    } catch (error) {
      throw new Error(`Error al obtener categorías de servicios: ${error.message}`);
    }
  }

  /**
   * Actualizar imágenes del servicio
   */
  async updateServiceImages(serviceId, images, businessId = null) {
    try {
      const whereClause = { id: serviceId };
      if (businessId) {
        whereClause.businessId = businessId;
      }

      const service = await Service.findOne({ where: whereClause });
      
      if (!service) {
        throw new Error('Servicio no encontrado');
      }

      await service.update({ images });
      return await this.getService(serviceId);
    } catch (error) {
      throw new Error(`Error al actualizar imágenes del servicio: ${error.message}`);
    }
  }

  /**
   * Obtener estadísticas de servicios
   */
  async getServicesStats(businessId, filters = {}) {
    try {
      const whereClause = { businessId };
      
      // Aplicar filtros de fecha si están presentes
      if (filters.startDate && filters.endDate) {
        whereClause.createdAt = {
          [Op.between]: [new Date(filters.startDate), new Date(filters.endDate)]
        };
      }

      const stats = await Service.findAll({
        where: whereClause,
        attributes: [
          [Service.sequelize.fn('COUNT', Service.sequelize.col('id')), 'totalServices'],
          [Service.sequelize.fn('COUNT', Service.sequelize.literal('CASE WHEN "isActive" = true THEN 1 END')), 'activeServices'],
          [Service.sequelize.fn('AVG', Service.sequelize.col('price')), 'avgPrice'],
          [Service.sequelize.fn('MIN', Service.sequelize.col('price')), 'minPrice'],
          [Service.sequelize.fn('MAX', Service.sequelize.col('price')), 'maxPrice'],
          [Service.sequelize.fn('AVG', Service.sequelize.col('duration')), 'avgDuration']
        ],
        raw: true
      });

      const categoryStats = await Service.findAll({
        where: whereClause,
        attributes: [
          'category',
          [Service.sequelize.fn('COUNT', Service.sequelize.col('id')), 'count'],
          [Service.sequelize.fn('AVG', Service.sequelize.col('price')), 'avgPrice']
        ],
        group: ['category'],
        order: [[Service.sequelize.fn('COUNT', Service.sequelize.col('id')), 'DESC']]
      });

      return {
        overview: {
          totalServices: parseInt(stats[0].totalServices) || 0,
          activeServices: parseInt(stats[0].activeServices) || 0,
          avgPrice: parseFloat(stats[0].avgPrice) || 0,
          minPrice: parseFloat(stats[0].minPrice) || 0,
          maxPrice: parseFloat(stats[0].maxPrice) || 0,
          avgDuration: parseFloat(stats[0].avgDuration) || 0
        },
        byCategory: categoryStats.map(cat => ({
          category: cat.category || 'Sin categoría',
          count: parseInt(cat.dataValues.count),
          avgPrice: parseFloat(cat.dataValues.avgPrice) || 0
        }))
      };
    } catch (error) {
      throw new Error(`Error al obtener estadísticas de servicios: ${error.message}`);
    }
  }

  // ================================
  // MÉTODOS DE INVENTARIO - PRODUCTOS
  // ================================

  /**
   * Obtener lista de productos del inventario
   */
  async getProducts(businessId, filters = {}) {
    try {
      const {
        category,
        isActive,
        trackInventory,
        stockStatus,
        search,
        page = 1,
        limit = 20,
        sortBy = 'name',
        sortOrder = 'ASC'
      } = filters;

      const whereClause = { businessId };
      
      // Aplicar filtros
      if (category) whereClause.category = category;
      if (typeof isActive === 'boolean') whereClause.isActive = isActive;
      if (typeof trackInventory === 'boolean') whereClause.trackInventory = trackInventory;
      
      if (search) {
        whereClause[Op.or] = [
          { name: { [Op.iLike]: `%${search}%` } },
          { sku: { [Op.iLike]: `%${search}%` } },
          { barcode: { [Op.iLike]: `%${search}%` } },
          { description: { [Op.iLike]: `%${search}%` } }
        ];
      }

      // Calcular offset para paginación
      const offset = (page - 1) * limit;

      let orderClause = [[sortBy, sortOrder.toUpperCase()]];
      
      const { count, rows } = await Product.findAndCountAll({
        where: whereClause,
        limit: parseInt(limit),
        offset: parseInt(offset),
        order: orderClause,
        include: [
          {
            model: InventoryMovement,
            as: 'movements',
            limit: 5,
            order: [['createdAt', 'DESC']]
          }
        ]
      });

      // Filtrar por stock status si se especifica
      let filteredProducts = rows;
      if (stockStatus) {
        filteredProducts = rows.filter(product => {
          const status = this.calculateStockStatus(product);
          return status === stockStatus;
        });
      }

      return {
        products: filteredProducts.map(product => ({
          ...product.toJSON(),
          stockStatus: this.calculateStockStatus(product),
          totalValue: product.currentStock * (product.cost || 0),
          retailValue: product.currentStock * product.price
        })),
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: count,
          pages: Math.ceil(count / limit)
        }
      };
    } catch (error) {
      throw new Error(`Error al obtener productos: ${error.message}`);
    }
  }

  /**
   * Obtener producto específico por ID
   */
  async getProduct(productId, businessId) {
    try {
      const product = await Product.findOne({
        where: { id: productId, businessId },
        include: [
          {
            model: InventoryMovement,
            as: 'movements',
            order: [['createdAt', 'DESC']],
            limit: 10
          }
        ]
      });

      if (!product) {
        throw new Error('Producto no encontrado');
      }

      return {
        ...product.toJSON(),
        stockStatus: this.calculateStockStatus(product),
        totalValue: product.currentStock * (product.cost || 0),
        retailValue: product.currentStock * product.price
      };
    } catch (error) {
      throw new Error(`Error al obtener producto: ${error.message}`);
    }
  }

  /**
   * Crear nuevo producto
   */
  async createProduct(businessId, productData) {
    try {
      // Generar SKU automáticamente si no se proporciona
      if (!productData.sku) {
        productData.sku = await this.generateSKU(businessId, productData.name);
      }

      // Validar que el SKU sea único
      const existingSKU = await Product.findOne({
        where: { businessId, sku: productData.sku }
      });

      if (existingSKU) {
        throw new Error('El SKU ya existe para este negocio');
      }

      const product = await Product.create({
        ...productData,
        businessId
      });

      // Si se especifica stock inicial, crear movimiento
      if (productData.initialStock && productData.initialStock > 0) {
        await this.createInventoryMovement(businessId, {
          productId: product.id,
          movementType: 'INITIAL_STOCK',
          quantity: productData.initialStock,
          unitCost: productData.cost || 0,
          reason: 'Stock inicial del producto',
          notes: 'Establecido al crear el producto'
        });
      }

      return this.getProduct(product.id, businessId);
    } catch (error) {
      throw new Error(`Error al crear producto: ${error.message}`);
    }
  }

  /**
   * Actualizar producto existente
   */
  async updateProduct(productId, businessId, productData) {
    try {
      const product = await Product.findOne({
        where: { id: productId, businessId }
      });

      if (!product) {
        throw new Error('Producto no encontrado');
      }

      // Si se actualiza el SKU, validar que sea único
      if (productData.sku && productData.sku !== product.sku) {
        const existingSKU = await Product.findOne({
          where: { 
            businessId, 
            sku: productData.sku,
            id: { [Op.ne]: productId }
          }
        });

        if (existingSKU) {
          throw new Error('El SKU ya existe para otro producto');
        }
      }

      await product.update(productData);
      return this.getProduct(productId, businessId);
    } catch (error) {
      throw new Error(`Error al actualizar producto: ${error.message}`);
    }
  }

  /**
   * Eliminar producto
   */
  async deleteProduct(productId, businessId) {
    try {
      const product = await Product.findOne({
        where: { id: productId, businessId }
      });

      if (!product) {
        throw new Error('Producto no encontrado');
      }

      // Verificar que no tenga stock
      if (product.trackInventory && product.currentStock > 0) {
        throw new Error('No se puede eliminar un producto con stock existente');
      }

      // Verificar que no tenga movimientos recientes
      const recentMovements = await InventoryMovement.findOne({
        where: { 
          productId,
          createdAt: {
            [Op.gte]: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // 30 días
          }
        }
      });

      if (recentMovements) {
        throw new Error('No se puede eliminar un producto con movimientos recientes');
      }

      await product.destroy();
      return { message: 'Producto eliminado exitosamente' };
    } catch (error) {
      throw new Error(`Error al eliminar producto: ${error.message}`);
    }
  }

  /**
   * Activar/Desactivar producto
   */
  async toggleProductStatus(productId, businessId, isActive) {
    try {
      const product = await Product.findOne({
        where: { id: productId, businessId }
      });

      if (!product) {
        throw new Error('Producto no encontrado');
      }

      await product.update({ isActive });
      return this.getProduct(productId, businessId);
    } catch (error) {
      throw new Error(`Error al cambiar estado del producto: ${error.message}`);
    }
  }

  // ================================
  // MÉTODOS DE GESTIÓN DE STOCK
  // ================================

  /**
   * Obtener niveles de stock
   */
  async getStockLevels(businessId, filters = {}) {
    try {
      const whereClause = { 
        businessId,
        trackInventory: true
      };

      if (filters.category) whereClause.category = filters.category;

      const products = await Product.findAll({
        where: whereClause,
        order: [['name', 'ASC']]
      });

      let filteredProducts = products;

      // Filtrar por estado de stock
      if (filters.stockStatus) {
        filteredProducts = products.filter(product => {
          return this.calculateStockStatus(product) === filters.stockStatus;
        });
      }

      if (filters.lowStock) {
        filteredProducts = products.filter(product => {
          return product.currentStock <= product.minStock;
        });
      }

      return filteredProducts.map(product => ({
        id: product.id,
        name: product.name,
        sku: product.sku,
        category: product.category,
        currentStock: product.currentStock,
        minStock: product.minStock,
        maxStock: product.maxStock,
        unit: product.unit,
        price: product.price,
        cost: product.cost,
        stockStatus: this.calculateStockStatus(product),
        totalValue: product.currentStock * (product.cost || 0),
        retailValue: product.currentStock * product.price,
        lastMovement: product.updatedAt
      }));
    } catch (error) {
      throw new Error(`Error al obtener niveles de stock: ${error.message}`);
    }
  }

  /**
   * Ajustar stock de un producto
   */
  async adjustStock(productId, businessId, adjustmentData) {
    try {
      const { quantity, reason, notes, unitCost } = adjustmentData;

      const product = await Product.findOne({
        where: { id: productId, businessId }
      });

      if (!product) {
        throw new Error('Producto no encontrado');
      }

      if (!product.trackInventory) {
        throw new Error('Este producto no tiene seguimiento de inventario habilitado');
      }

      // Verificar que el ajuste no resulte en stock negativo
      if (product.currentStock + quantity < 0) {
        throw new Error('El ajuste resultaría en stock negativo');
      }

      // Crear movimiento de inventario
      const movement = await this.createInventoryMovement(businessId, {
        productId,
        movementType: 'ADJUSTMENT',
        quantity,
        unitCost: unitCost || product.cost || 0,
        reason,
        notes,
        stockBefore: product.currentStock,
        stockAfter: product.currentStock + quantity
      });

      return movement;
    } catch (error) {
      throw new Error(`Error al ajustar stock: ${error.message}`);
    }
  }

  /**
   * Establecer stock inicial
   */
  async setInitialStock(productId, businessId, initialStockData) {
    try {
      const { quantity, unitCost, notes } = initialStockData;

      const product = await Product.findOne({
        where: { id: productId, businessId }
      });

      if (!product) {
        throw new Error('Producto no encontrado');
      }

      if (!product.trackInventory) {
        throw new Error('Este producto no tiene seguimiento de inventario habilitado');
      }

      // Verificar que no tenga movimientos previos
      const existingMovements = await InventoryMovement.findOne({
        where: { productId }
      });

      if (existingMovements) {
        throw new Error('El producto ya tiene movimientos de inventario. Use ajuste de stock.');
      }

      // Crear movimiento de stock inicial
      const movement = await this.createInventoryMovement(businessId, {
        productId,
        movementType: 'INITIAL_STOCK',
        quantity,
        unitCost: unitCost || product.cost || 0,
        reason: 'Stock inicial del producto',
        notes,
        stockBefore: 0,
        stockAfter: quantity
      });

      return movement;
    } catch (error) {
      throw new Error(`Error al establecer stock inicial: ${error.message}`);
    }
  }

  /**
   * Transferir stock entre productos
   */
  async transferStock(businessId, transferData) {
    try {
      const { fromProductId, toProductId, quantity, reason, notes } = transferData;

      // Validar producto origen
      const fromProduct = await Product.findOne({
        where: { id: fromProductId, businessId }
      });

      if (!fromProduct) {
        throw new Error('Producto origen no encontrado');
      }

      if (!fromProduct.trackInventory) {
        throw new Error('El producto origen no tiene seguimiento de inventario');
      }

      if (fromProduct.currentStock < quantity) {
        throw new Error('Stock insuficiente en el producto origen');
      }

      let toProduct = null;
      if (toProductId) {
        toProduct = await Product.findOne({
          where: { id: toProductId, businessId }
        });

        if (!toProduct) {
          throw new Error('Producto destino no encontrado');
        }

        if (!toProduct.trackInventory) {
          throw new Error('El producto destino no tiene seguimiento de inventario');
        }
      }

      // Crear movimiento de salida
      const outMovement = await this.createInventoryMovement(businessId, {
        productId: fromProductId,
        movementType: 'TRANSFER',
        quantity: -quantity,
        reason: `Transferencia: ${reason}`,
        notes: `Transferido a: ${toProduct ? toProduct.name : 'N/A'}. ${notes || ''}`,
        stockBefore: fromProduct.currentStock,
        stockAfter: fromProduct.currentStock - quantity
      });

      let inMovement = null;
      if (toProduct) {
        // Crear movimiento de entrada
        inMovement = await this.createInventoryMovement(businessId, {
          productId: toProductId,
          movementType: 'TRANSFER',
          quantity: quantity,
          reason: `Transferencia: ${reason}`,
          notes: `Recibido de: ${fromProduct.name}. ${notes || ''}`,
          stockBefore: toProduct.currentStock,
          stockAfter: toProduct.currentStock + quantity
        });
      }

      return {
        outMovement,
        inMovement,
        message: 'Transferencia completada exitosamente'
      };
    } catch (error) {
      throw new Error(`Error al transferir stock: ${error.message}`);
    }
  }

  /**
   * Obtener productos con stock bajo
   */
  async getLowStockProducts(businessId) {
    try {
      const products = await Product.findAll({
        where: {
          businessId,
          trackInventory: true,
          isActive: true,
          [Op.or]: [
            { currentStock: { [Op.lte]: { [Op.col]: 'minStock' } } },
            { currentStock: 0 }
          ]
        },
        order: [['currentStock', 'ASC']]
      });

      return products.map(product => ({
        id: product.id,
        name: product.name,
        sku: product.sku,
        category: product.category,
        currentStock: product.currentStock,
        minStock: product.minStock,
        unit: product.unit,
        stockStatus: this.calculateStockStatus(product),
        urgency: product.currentStock === 0 ? 'CRITICAL' : 'WARNING'
      }));
    } catch (error) {
      throw new Error(`Error al obtener productos con stock bajo: ${error.message}`);
    }
  }

  /**
   * Obtener productos próximos a vencer
   */
  async getExpiringProducts(businessId, days = 30) {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() + days);

      const products = await Product.findAll({
        where: {
          businessId,
          expirationTracking: true,
          isActive: true
        },
        include: [
          {
            model: InventoryMovement,
            as: 'movements',
            where: {
              expirationDate: {
                [Op.lte]: cutoffDate
              },
              quantity: { [Op.gt]: 0 } // Solo movimientos positivos (entradas)
            },
            order: [['expirationDate', 'ASC']]
          }
        ]
      });

      const expiringItems = [];
      
      products.forEach(product => {
        product.movements.forEach(movement => {
          if (movement.expirationDate) {
            const daysUntilExpiry = Math.ceil(
              (new Date(movement.expirationDate) - new Date()) / (1000 * 60 * 60 * 24)
            );

            expiringItems.push({
              productId: product.id,
              productName: product.name,
              sku: product.sku,
              batchNumber: movement.batchNumber,
              expirationDate: movement.expirationDate,
              daysUntilExpiry,
              quantity: movement.quantity,
              urgency: daysUntilExpiry <= 7 ? 'CRITICAL' : 
                      daysUntilExpiry <= 15 ? 'HIGH' : 'MEDIUM'
            });
          }
        });
      });

      return expiringItems.sort((a, b) => a.daysUntilExpiry - b.daysUntilExpiry);
    } catch (error) {
      throw new Error(`Error al obtener productos próximos a vencer: ${error.message}`);
    }
  }

  // ================================
  // MÉTODOS DE MOVIMIENTOS DE INVENTARIO
  // ================================

  /**
   * Obtener historial de movimientos
   */
  async getInventoryMovements(businessId, filters = {}) {
    try {
      const {
        productId,
        movementType,
        startDate,
        endDate,
        page = 1,
        limit = 20
      } = filters;

      const whereClause = { businessId };

      if (productId) whereClause.productId = productId;
      if (movementType) whereClause.movementType = movementType;
      
      if (startDate && endDate) {
        whereClause.createdAt = {
          [Op.between]: [new Date(startDate), new Date(endDate)]
        };
      }

      const offset = (page - 1) * limit;

      const { count, rows } = await InventoryMovement.findAndCountAll({
        where: whereClause,
        limit: parseInt(limit),
        offset: parseInt(offset),
        order: [['createdAt', 'DESC']],
        include: [
          {
            model: Product,
            as: 'product',
            attributes: ['id', 'name', 'sku', 'unit']
          }
        ]
      });

      return {
        movements: rows,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: count,
          pages: Math.ceil(count / limit)
        }
      };
    } catch (error) {
      throw new Error(`Error al obtener movimientos de inventario: ${error.message}`);
    }
  }

  /**
   * Obtener movimiento específico
   */
  async getInventoryMovement(movementId, businessId) {
    try {
      const movement = await InventoryMovement.findOne({
        where: { id: movementId, businessId },
        include: [
          {
            model: Product,
            as: 'product',
            attributes: ['id', 'name', 'sku', 'unit', 'trackInventory']
          }
        ]
      });

      if (!movement) {
        throw new Error('Movimiento no encontrado');
      }

      return movement;
    } catch (error) {
      throw new Error(`Error al obtener movimiento: ${error.message}`);
    }
  }

  /**
   * Crear movimiento de inventario
   */
  async createInventoryMovement(businessId, movementData) {
    try {
      const {
        productId,
        movementType,
        quantity,
        reason,
        notes,
        unitCost,
        batchNumber,
        expirationDate,
        supplierInfo,
        stockBefore,
        stockAfter
      } = movementData;

      // Validar el producto
      const product = await Product.findOne({
        where: { id: productId, businessId }
      });

      if (!product) {
        throw new Error('Producto no encontrado');
      }

      if (!product.trackInventory) {
        throw new Error('Este producto no tiene seguimiento de inventario habilitado');
      }

      // Calcular stock antes y después si no se proporcionan
      const currentStock = stockBefore !== undefined ? stockBefore : product.currentStock;
      const newStock = stockAfter !== undefined ? stockAfter : currentStock + quantity;

      // Validar que el stock no sea negativo
      if (newStock < 0) {
        throw new Error('El movimiento resultaría en stock negativo');
      }

      // Crear el movimiento
      const movement = await InventoryMovement.create({
        businessId,
        productId,
        movementType,
        quantity,
        unitCost: unitCost || product.cost || 0,
        totalCost: (unitCost || product.cost || 0) * Math.abs(quantity),
        reason,
        notes,
        batchNumber,
        expirationDate,
        supplierInfo,
        stockBefore: currentStock,
        stockAfter: newStock
      });

      // Actualizar el stock del producto
      await product.update({
        currentStock: newStock,
        lastMovementDate: new Date()
      });

      return this.getInventoryMovement(movement.id, businessId);
    } catch (error) {
      throw new Error(`Error al crear movimiento de inventario: ${error.message}`);
    }
  }

  // ================================
  // MÉTODOS DE CATEGORÍAS
  // ================================

  /**
   * Obtener categorías de productos
   */
  async getProductCategories(businessId) {
    try {
      const categories = await Product.findAll({
        where: { businessId },
        attributes: [
          'category',
          [Product.sequelize.fn('COUNT', Product.sequelize.col('id')), 'productCount'],
          [Product.sequelize.fn('SUM', Product.sequelize.literal('CASE WHEN "trackInventory" = true THEN "currentStock" ELSE 0 END')), 'totalStock'],
          [Product.sequelize.fn('SUM', Product.sequelize.literal('CASE WHEN "trackInventory" = true THEN "currentStock" * "cost" ELSE 0 END')), 'totalValue']
        ],
        group: ['category'],
        order: [[Product.sequelize.fn('COUNT', Product.sequelize.col('id')), 'DESC']]
      });

      return categories.map(cat => ({
        name: cat.category || 'Sin categoría',
        productCount: parseInt(cat.dataValues.productCount),
        totalStock: parseInt(cat.dataValues.totalStock) || 0,
        totalValue: parseFloat(cat.dataValues.totalValue) || 0
      }));
    } catch (error) {
      throw new Error(`Error al obtener categorías: ${error.message}`);
    }
  }

  // ================================
  // MÉTODOS DE REPORTES Y ESTADÍSTICAS
  // ================================

  /**
   * Obtener resumen de inventario
   */
  async getInventorySummary(businessId) {
    try {
      const totalProducts = await Product.count({
        where: { businessId }
      });

      const activeProducts = await Product.count({
        where: { businessId, isActive: true }
      });

      const trackedProducts = await Product.count({
        where: { businessId, trackInventory: true }
      });

      const stockValue = await Product.sum('currentStock * cost', {
        where: { 
          businessId, 
          trackInventory: true,
          cost: { [Op.not]: null }
        }
      });

      const retailValue = await Product.sum('currentStock * price', {
        where: { 
          businessId, 
          trackInventory: true 
        }
      });

      const lowStockCount = await Product.count({
        where: {
          businessId,
          trackInventory: true,
          [Op.or]: [
            { currentStock: { [Op.lte]: { [Op.col]: 'minStock' } } },
            { currentStock: 0 }
          ]
        }
      });

      const outOfStockCount = await Product.count({
        where: {
          businessId,
          trackInventory: true,
          currentStock: 0
        }
      });

      // Movimientos del último mes
      const lastMonth = new Date();
      lastMonth.setMonth(lastMonth.getMonth() - 1);

      const recentMovements = await InventoryMovement.count({
        where: {
          businessId,
          createdAt: { [Op.gte]: lastMonth }
        }
      });

      return {
        products: {
          total: totalProducts,
          active: activeProducts,
          tracked: trackedProducts,
          lowStock: lowStockCount,
          outOfStock: outOfStockCount
        },
        value: {
          stockValue: stockValue || 0,
          retailValue: retailValue || 0,
          potentialProfit: (retailValue || 0) - (stockValue || 0)
        },
        activity: {
          recentMovements,
          lastUpdated: new Date()
        }
      };
    } catch (error) {
      throw new Error(`Error al obtener resumen de inventario: ${error.message}`);
    }
  }

  /**
   * Obtener estadísticas de movimientos
   */
  async getMovementStats(businessId, filters = {}) {
    try {
      const { period = 'month', startDate, endDate } = filters;
      
      let dateFilter = {};
      if (startDate && endDate) {
        dateFilter = {
          createdAt: {
            [Op.between]: [new Date(startDate), new Date(endDate)]
          }
        };
      } else {
        // Período predeterminado
        const now = new Date();
        let start = new Date();
        
        switch (period) {
          case 'week':
            start.setDate(now.getDate() - 7);
            break;
          case 'month':
            start.setMonth(now.getMonth() - 1);
            break;
          case 'quarter':
            start.setMonth(now.getMonth() - 3);
            break;
          case 'year':
            start.setFullYear(now.getFullYear() - 1);
            break;
        }
        
        dateFilter = {
          createdAt: { [Op.gte]: start }
        };
      }

      const movementsByType = await InventoryMovement.findAll({
        where: { businessId, ...dateFilter },
        attributes: [
          'movementType',
          [InventoryMovement.sequelize.fn('COUNT', InventoryMovement.sequelize.col('id')), 'count'],
          [InventoryMovement.sequelize.fn('SUM', InventoryMovement.sequelize.col('quantity')), 'totalQuantity'],
          [InventoryMovement.sequelize.fn('SUM', InventoryMovement.sequelize.col('totalCost')), 'totalCost']
        ],
        group: ['movementType'],
        order: [[InventoryMovement.sequelize.fn('COUNT', InventoryMovement.sequelize.col('id')), 'DESC']]
      });

      const dailyMovements = await InventoryMovement.findAll({
        where: { businessId, ...dateFilter },
        attributes: [
          [InventoryMovement.sequelize.fn('DATE', InventoryMovement.sequelize.col('createdAt')), 'date'],
          [InventoryMovement.sequelize.fn('COUNT', InventoryMovement.sequelize.col('id')), 'count']
        ],
        group: [InventoryMovement.sequelize.fn('DATE', InventoryMovement.sequelize.col('createdAt'))],
        order: [[InventoryMovement.sequelize.fn('DATE', InventoryMovement.sequelize.col('createdAt')), 'ASC']]
      });

      return {
        byType: movementsByType.map(movement => ({
          type: movement.movementType,
          count: parseInt(movement.dataValues.count),
          totalQuantity: parseInt(movement.dataValues.totalQuantity) || 0,
          totalCost: parseFloat(movement.dataValues.totalCost) || 0
        })),
        daily: dailyMovements.map(movement => ({
          date: movement.dataValues.date,
          count: parseInt(movement.dataValues.count)
        }))
      };
    } catch (error) {
      throw new Error(`Error al obtener estadísticas de movimientos: ${error.message}`);
    }
  }

  /**
   * Obtener análisis ABC de productos
   */
  async getABCAnalysis(businessId) {
    try {
      // Obtener productos con su valor de inventario
      const products = await Product.findAll({
        where: { 
          businessId, 
          trackInventory: true,
          currentStock: { [Op.gt]: 0 }
        },
        attributes: [
          'id', 'name', 'sku', 'category', 'currentStock', 'cost', 'price',
          [Product.sequelize.literal('("currentStock" * "cost")'), 'inventoryValue']
        ],
        order: [[Product.sequelize.literal('("currentStock" * "cost")'), 'DESC']]
      });

      const totalValue = products.reduce((sum, product) => {
        return sum + (product.dataValues.inventoryValue || 0);
      }, 0);

      let cumulativeValue = 0;
      const analysis = products.map(product => {
        const value = product.dataValues.inventoryValue || 0;
        cumulativeValue += value;
        const percentage = totalValue > 0 ? (cumulativeValue / totalValue) * 100 : 0;

        let category = 'C';
        if (percentage <= 80) category = 'A';
        else if (percentage <= 95) category = 'B';

        return {
          id: product.id,
          name: product.name,
          sku: product.sku,
          category: product.category,
          currentStock: product.currentStock,
          cost: product.cost,
          price: product.price,
          inventoryValue: value,
          cumulativePercentage: percentage,
          abcCategory: category
        };
      });

      // Contar productos por categoría ABC
      const categoryCounts = analysis.reduce((counts, product) => {
        counts[product.abcCategory] = (counts[product.abcCategory] || 0) + 1;
        return counts;
      }, {});

      return {
        products: analysis,
        summary: {
          totalProducts: products.length,
          totalValue,
          categoryA: categoryCounts.A || 0,
          categoryB: categoryCounts.B || 0,
          categoryC: categoryCounts.C || 0
        }
      };
    } catch (error) {
      throw new Error(`Error al obtener análisis ABC: ${error.message}`);
    }
  }

  // ================================
  // MÉTODOS AUXILIARES DE INVENTARIO
  // ================================

  /**
   * Calcular estado del stock
   */
  calculateStockStatus(product) {
    if (!product.trackInventory) return 'NO_TRACKED';
    
    const { currentStock, minStock, maxStock } = product;
    
    if (currentStock === 0) return 'OUT_OF_STOCK';
    if (currentStock <= minStock) return 'LOW_STOCK';
    if (maxStock && currentStock >= maxStock) return 'OVERSTOCK';
    
    return 'IN_STOCK';
  }

  /**
   * Generar SKU automático
   */
  async generateSKU(businessId, productName) {
    try {
      // Usar las primeras 3 letras del nombre del producto
      const prefix = productName.substring(0, 3).toUpperCase().replace(/[^A-Z]/g, '');
      
      // Obtener el último número usado para este prefijo
      const lastProduct = await Product.findOne({
        where: {
          businessId,
          sku: { [Op.like]: `${prefix}%` }
        },
        order: [['sku', 'DESC']]
      });

      let nextNumber = 1;
      if (lastProduct) {
        const lastNumber = parseInt(lastProduct.sku.replace(prefix, '')) || 0;
        nextNumber = lastNumber + 1;
      }

      return `${prefix}${nextNumber.toString().padStart(4, '0')}`;
    } catch (error) {
      // Si hay error, generar SKU con timestamp
      return `PRD${Date.now().toString().slice(-6)}`;
    }
  }

  // ================================
  // GESTIÓN DE PROVEEDORES
  // ================================

  /**
   * Obtener proveedores con filtros
   */
  async getSuppliers(businessId, filters = {}) {
    try {
      const {
        type,
        status = 'ACTIVE',
        category,
        search,
        country,
        city,
        hasActiveOrders,
        page = 1,
        limit = 10,
        sortBy = 'name',
        sortOrder = 'ASC'
      } = filters;

      const where = { businessId };
      const include = [];

      // Filtros de estado
      if (status !== 'ALL') {
        where.status = status;
      }

      // Filtros adicionales
      if (type) where.type = type;
      if (category) {
        where.categories = { [Op.contains]: [category] };
      }

      // Búsqueda por texto
      if (search) {
        where[Op.or] = [
          { name: { [Op.iLike]: `%${search}%` } },
          { code: { [Op.iLike]: `%${search}%` } },
          { email: { [Op.iLike]: `%${search}%` } },
          { taxId: { [Op.iLike]: `%${search}%` } }
        ];
      }

      // Filtros geográficos
      if (country) {
        where['address.country'] = { [Op.iLike]: `%${country}%` };
      }
      if (city) {
        where['address.city'] = { [Op.iLike]: `%${city}%` };
      }

      // Incluir información de órdenes activas si se solicita
      if (hasActiveOrders !== undefined) {
        include.push({
          model: PurchaseOrder,
          as: 'purchaseOrders',
          attributes: ['id', 'status'],
          where: hasActiveOrders ? {
            status: { [Op.in]: ['SENT', 'CONFIRMED', 'PARTIALLY_RECEIVED'] }
          } : undefined,
          required: hasActiveOrders
        });
      }

      const offset = (page - 1) * limit;
      const order = [[sortBy, sortOrder.toUpperCase()]];

      const { count, rows } = await Supplier.findAndCountAll({
        where,
        include,
        order,
        limit: parseInt(limit),
        offset: parseInt(offset),
        distinct: true
      });

      // Calcular estadísticas para cada proveedor
      const suppliersWithStats = await Promise.all(
        rows.map(async (supplier) => {
          const stats = await this.getSupplierStats(supplier.id);
          return {
            ...supplier.toJSON(),
            stats
          };
        })
      );

      return {
        suppliers: suppliersWithStats,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(count / limit),
          totalItems: count,
          itemsPerPage: parseInt(limit)
        }
      };
    } catch (error) {
      console.error('Error getting suppliers:', error);
      throw new Error('Error al obtener proveedores');
    }
  }

  /**
   * Obtener proveedor específico
   */
  async getSupplier(businessId, supplierId) {
    try {
      const supplier = await Supplier.findOne({
        where: {
          id: supplierId,
          businessId
        },
        include: [
          {
            model: PurchaseOrder,
            as: 'purchaseOrders',
            limit: 5,
            order: [['createdAt', 'DESC']]
          },
          {
            model: SupplierInvoice,
            as: 'invoices',
            limit: 5,
            order: [['issueDate', 'DESC']]
          },
          {
            model: SupplierEvaluation,
            as: 'evaluations',
            limit: 3,
            order: [['createdAt', 'DESC']]
          }
        ]
      });

      if (!supplier) {
        throw new Error('Proveedor no encontrado');
      }

      // Obtener estadísticas del proveedor
      const stats = await this.getSupplierStats(supplierId);
      
      // Obtener productos del catálogo
      const catalog = await this.getSupplierCatalog(supplierId, { limit: 10 });

      return {
        ...supplier.toJSON(),
        stats,
        catalogPreview: catalog.products
      };
    } catch (error) {
      console.error('Error getting supplier:', error);
      throw error;
    }
  }

  /**
   * Crear nuevo proveedor
   */
  async createSupplier(businessId, supplierData) {
    const transaction = await sequelize.transaction();
    
    try {
      // Generar código si no se proporciona
      if (!supplierData.code) {
        supplierData.code = await this.generateSupplierCode(businessId, supplierData.name);
      }

      // Validar que el código sea único
      const existingSupplier = await Supplier.findOne({
        where: {
          businessId,
          [Op.or]: [
            { code: supplierData.code },
            { email: supplierData.email }
          ]
        }
      });

      if (existingSupplier) {
        throw new Error('Ya existe un proveedor con ese código o email');
      }

      const supplier = await Supplier.create({
        ...supplierData,
        businessId,
        status: supplierData.status || 'ACTIVE'
      }, { transaction });

      // Crear contacto principal si se proporciona
      if (supplierData.contactPerson) {
        await SupplierContact.create({
          supplierId: supplier.id,
          ...supplierData.contactPerson,
          isPrimary: true
        }, { transaction });
      }

      await transaction.commit();

      // Retornar proveedor con relaciones
      return await this.getSupplier(businessId, supplier.id);
    } catch (error) {
      await transaction.rollback();
      console.error('Error creating supplier:', error);
      throw error;
    }
  }

  /**
   * Actualizar proveedor
   */
  async updateSupplier(businessId, supplierId, supplierData) {
    const transaction = await sequelize.transaction();
    
    try {
      const supplier = await Supplier.findOne({
        where: { id: supplierId, businessId }
      });

      if (!supplier) {
        throw new Error('Proveedor no encontrado');
      }

      // Validar código único si se está cambiando
      if (supplierData.code && supplierData.code !== supplier.code) {
        const existingSupplier = await Supplier.findOne({
          where: {
            businessId,
            code: supplierData.code,
            id: { [Op.ne]: supplierId }
          }
        });

        if (existingSupplier) {
          throw new Error('Ya existe un proveedor con ese código');
        }
      }

      await supplier.update(supplierData, { transaction });

      await transaction.commit();

      return await this.getSupplier(businessId, supplierId);
    } catch (error) {
      await transaction.rollback();
      console.error('Error updating supplier:', error);
      throw error;
    }
  }

  /**
   * Eliminar proveedor
   */
  async deleteSupplier(businessId, supplierId) {
    const transaction = await sequelize.transaction();
    
    try {
      const supplier = await Supplier.findOne({
        where: { id: supplierId, businessId }
      });

      if (!supplier) {
        throw new Error('Proveedor no encontrado');
      }

      // Verificar que no tenga órdenes activas
      const activeOrders = await PurchaseOrder.count({
        where: {
          supplierId,
          status: { [Op.in]: ['SENT', 'CONFIRMED', 'PARTIALLY_RECEIVED'] }
        }
      });

      if (activeOrders > 0) {
        throw new Error('No se puede eliminar un proveedor con órdenes activas');
      }

      // Verificar que no tenga facturas pendientes
      const pendingInvoices = await SupplierInvoice.count({
        where: {
          supplierId,
          status: { [Op.in]: ['PENDING', 'APPROVED'] }
        }
      });

      if (pendingInvoices > 0) {
        throw new Error('No se puede eliminar un proveedor con facturas pendientes');
      }

      await supplier.destroy({ transaction });
      await transaction.commit();

      return { message: 'Proveedor eliminado exitosamente' };
    } catch (error) {
      await transaction.rollback();
      console.error('Error deleting supplier:', error);
      throw error;
    }
  }

  /**
   * Cambiar estado del proveedor
   */
  async updateSupplierStatus(businessId, supplierId, status) {
    try {
      const supplier = await Supplier.findOne({
        where: { id: supplierId, businessId }
      });

      if (!supplier) {
        throw new Error('Proveedor no encontrado');
      }

      await supplier.update({ status });

      return await this.getSupplier(businessId, supplierId);
    } catch (error) {
      console.error('Error updating supplier status:', error);
      throw error;
    }
  }

  // ================================
  // GESTIÓN DE CONTACTOS
  // ================================

  /**
   * Obtener contactos del proveedor
   */
  async getSupplierContacts(supplierId) {
    try {
      const contacts = await SupplierContact.findAll({
        where: { supplierId },
        order: [['isPrimary', 'DESC'], ['name', 'ASC']]
      });

      return contacts;
    } catch (error) {
      console.error('Error getting supplier contacts:', error);
      throw new Error('Error al obtener contactos del proveedor');
    }
  }

  /**
   * Agregar contacto al proveedor
   */
  async addSupplierContact(supplierId, contactData) {
    const transaction = await sequelize.transaction();
    
    try {
      // Si es contacto principal, desmarcar otros
      if (contactData.isPrimary) {
        await SupplierContact.update(
          { isPrimary: false },
          { where: { supplierId }, transaction }
        );
      }

      const contact = await SupplierContact.create({
        ...contactData,
        supplierId
      }, { transaction });

      await transaction.commit();
      return contact;
    } catch (error) {
      await transaction.rollback();
      console.error('Error adding supplier contact:', error);
      throw new Error('Error al agregar contacto');
    }
  }

  /**
   * Actualizar contacto del proveedor
   */
  async updateSupplierContact(supplierId, contactId, contactData) {
    const transaction = await sequelize.transaction();
    
    try {
      const contact = await SupplierContact.findOne({
        where: { id: contactId, supplierId }
      });

      if (!contact) {
        throw new Error('Contacto no encontrado');
      }

      // Si se marca como principal, desmarcar otros
      if (contactData.isPrimary && !contact.isPrimary) {
        await SupplierContact.update(
          { isPrimary: false },
          { where: { supplierId, id: { [Op.ne]: contactId } }, transaction }
        );
      }

      await contact.update(contactData, { transaction });
      await transaction.commit();

      return contact;
    } catch (error) {
      await transaction.rollback();
      console.error('Error updating supplier contact:', error);
      throw error;
    }
  }

  /**
   * Eliminar contacto del proveedor
   */
  async deleteSupplierContact(supplierId, contactId) {
    try {
      const contact = await SupplierContact.findOne({
        where: { id: contactId, supplierId }
      });

      if (!contact) {
        throw new Error('Contacto no encontrado');
      }

      await contact.destroy();
      return { message: 'Contacto eliminado exitosamente' };
    } catch (error) {
      console.error('Error deleting supplier contact:', error);
      throw error;
    }
  }

  // ================================
  // ÓRDENES DE COMPRA
  // ================================

  /**
   * Obtener órdenes de compra
   */
  async getPurchaseOrders(businessId, filters = {}) {
    try {
      const {
        supplierId,
        status,
        startDate,
        endDate,
        page = 1,
        limit = 10
      } = filters;

      const where = { businessId };
      
      if (supplierId) where.supplierId = supplierId;
      if (status) where.status = status;
      
      if (startDate || endDate) {
        where.createdAt = {};
        if (startDate) where.createdAt[Op.gte] = new Date(startDate);
        if (endDate) where.createdAt[Op.lte] = new Date(endDate);
      }

      const offset = (page - 1) * limit;

      const { count, rows } = await PurchaseOrder.findAndCountAll({
        where,
        include: [
          {
            model: Supplier,
            as: 'supplier',
            attributes: ['id', 'name', 'code']
          }
        ],
        order: [['createdAt', 'DESC']],
        limit: parseInt(limit),
        offset: parseInt(offset)
      });

      return {
        orders: rows,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(count / limit),
          totalItems: count,
          itemsPerPage: parseInt(limit)
        }
      };
    } catch (error) {
      console.error('Error getting purchase orders:', error);
      throw new Error('Error al obtener órdenes de compra');
    }
  }

  /**
   * Obtener orden de compra específica
   */
  async getPurchaseOrder(businessId, orderId) {
    try {
      const order = await PurchaseOrder.findOne({
        where: { id: orderId, businessId },
        include: [
          {
            model: Supplier,
            as: 'supplier'
          }
        ]
      });

      if (!order) {
        throw new Error('Orden de compra no encontrada');
      }

      return order;
    } catch (error) {
      console.error('Error getting purchase order:', error);
      throw error;
    }
  }

  /**
   * Crear orden de compra
   */
  async createPurchaseOrder(businessId, orderData) {
    const transaction = await sequelize.transaction();
    
    try {
      // Generar número de orden
      const orderNumber = await this.generateOrderNumber(businessId);
      
      // Calcular totales
      const totals = this.calculateOrderTotals(orderData.items);

      const order = await PurchaseOrder.create({
        ...orderData,
        businessId,
        orderNumber,
        subtotal: totals.subtotal,
        tax: totals.tax,
        total: totals.total,
        status: 'DRAFT'
      }, { transaction });

      await transaction.commit();

      return await this.getPurchaseOrder(businessId, order.id);
    } catch (error) {
      await transaction.rollback();
      console.error('Error creating purchase order:', error);
      throw error;
    }
  }

  /**
   * Actualizar orden de compra
   */
  async updatePurchaseOrder(businessId, orderId, orderData) {
    const transaction = await sequelize.transaction();
    
    try {
      const order = await PurchaseOrder.findOne({
        where: { id: orderId, businessId }
      });

      if (!order) {
        throw new Error('Orden de compra no encontrada');
      }

      if (order.status === 'RECEIVED') {
        throw new Error('No se puede modificar una orden ya recibida');
      }

      // Recalcular totales si se modifican los items
      if (orderData.items) {
        const totals = this.calculateOrderTotals(orderData.items);
        orderData.subtotal = totals.subtotal;
        orderData.tax = totals.tax;
        orderData.total = totals.total;
      }

      await order.update(orderData, { transaction });
      await transaction.commit();

      return await this.getPurchaseOrder(businessId, orderId);
    } catch (error) {
      await transaction.rollback();
      console.error('Error updating purchase order:', error);
      throw error;
    }
  }

  /**
   * Cambiar estado de orden de compra
   */
  async updatePurchaseOrderStatus(businessId, orderId, status, metadata = {}) {
    try {
      const order = await PurchaseOrder.findOne({
        where: { id: orderId, businessId }
      });

      if (!order) {
        throw new Error('Orden de compra no encontrada');
      }

      await order.update({
        status,
        ...metadata
      });

      return await this.getPurchaseOrder(businessId, orderId);
    } catch (error) {
      console.error('Error updating purchase order status:', error);
      throw error;
    }
  }

  // ================================
  // GESTIÓN DE FACTURAS
  // ================================

  /**
   * Obtener facturas de proveedores
   */
  async getSupplierInvoices(businessId, filters = {}) {
    try {
      const {
        supplierId,
        status,
        startDate,
        endDate,
        overdue,
        page = 1,
        limit = 10
      } = filters;

      const where = { businessId };
      
      if (supplierId) where.supplierId = supplierId;
      if (status) where.status = status;
      
      if (startDate || endDate) {
        where.issueDate = {};
        if (startDate) where.issueDate[Op.gte] = new Date(startDate);
        if (endDate) where.issueDate[Op.lte] = new Date(endDate);
      }

      if (overdue) {
        where.dueDate = { [Op.lt]: new Date() };
        where.status = { [Op.in]: ['PENDING', 'APPROVED'] };
      }

      const offset = (page - 1) * limit;

      const { count, rows } = await SupplierInvoice.findAndCountAll({
        where,
        include: [
          {
            model: Supplier,
            as: 'supplier',
            attributes: ['id', 'name', 'code']
          }
        ],
        order: [['issueDate', 'DESC']],
        limit: parseInt(limit),
        offset: parseInt(offset)
      });

      return {
        invoices: rows,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(count / limit),
          totalItems: count,
          itemsPerPage: parseInt(limit)
        }
      };
    } catch (error) {
      console.error('Error getting supplier invoices:', error);
      throw new Error('Error al obtener facturas de proveedores');
    }
  }

  /**
   * Crear factura de proveedor
   */
  async createSupplierInvoice(businessId, invoiceData) {
    const transaction = await sequelize.transaction();
    
    try {
      const invoice = await SupplierInvoice.create({
        ...invoiceData,
        businessId,
        status: 'PENDING'
      }, { transaction });

      await transaction.commit();
      return invoice;
    } catch (error) {
      await transaction.rollback();
      console.error('Error creating supplier invoice:', error);
      throw error;
    }
  }

  // ================================
  // CATÁLOGO DE PRODUCTOS
  // ================================

  /**
   * Obtener catálogo del proveedor
   */
  async getSupplierCatalog(supplierId, filters = {}) {
    try {
      const {
        category,
        search,
        available,
        page = 1,
        limit = 20
      } = filters;

      const where = { supplierId };
      
      if (category) where.category = category;
      if (search) {
        where[Op.or] = [
          { name: { [Op.iLike]: `%${search}%` } },
          { supplierSku: { [Op.iLike]: `%${search}%` } }
        ];
      }
      if (typeof available === 'boolean') where.available = available;

      const offset = (page - 1) * limit;

      const { count, rows } = await SupplierCatalogItem.findAndCountAll({
        where,
        order: [['name', 'ASC']],
        limit: parseInt(limit),
        offset: parseInt(offset)
      });

      return {
        products: rows,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(count / limit),
          totalItems: count,
          itemsPerPage: parseInt(limit)
        }
      };
    } catch (error) {
      console.error('Error getting supplier catalog:', error);
      throw new Error('Error al obtener catálogo del proveedor');
    }
  }

  // ================================
  // EVALUACIONES DE PROVEEDORES
  // ================================

  /**
   * Crear evaluación de proveedor
   */
  async createSupplierEvaluation(supplierId, evaluationData) {
    try {
      const evaluation = await SupplierEvaluation.create({
        ...evaluationData,
        supplierId
      });

      return evaluation;
    } catch (error) {
      console.error('Error creating supplier evaluation:', error);
      throw new Error('Error al crear evaluación');
    }
  }

  // ================================
  // REPORTES Y ESTADÍSTICAS
  // ================================

  /**
   * Obtener estadísticas de proveedor
   */
  async getSupplierStats(supplierId) {
    try {
      const [
        totalOrders,
        totalSpent,
        pendingInvoices,
        averageRating
      ] = await Promise.all([
        PurchaseOrder.count({ where: { supplierId } }),
        PurchaseOrder.sum('total', { where: { supplierId, status: 'RECEIVED' } }),
        SupplierInvoice.count({ where: { supplierId, status: 'PENDING' } }),
        SupplierEvaluation.findOne({
          where: { supplierId },
          attributes: [
            [sequelize.fn('AVG', 
              sequelize.literal('(quality_score + delivery_score + service_score + price_score) / 4')
            ), 'averageRating']
          ]
        })
      ]);

      return {
        totalOrders: totalOrders || 0,
        totalSpent: totalSpent || 0,
        pendingInvoices: pendingInvoices || 0,
        averageRating: averageRating?.averageRating ? parseFloat(averageRating.averageRating).toFixed(1) : 0
      };
    } catch (error) {
      console.error('Error getting supplier stats:', error);
      return {
        totalOrders: 0,
        totalSpent: 0,
        pendingInvoices: 0,
        averageRating: 0
      };
    }
  }

  /**
   * Obtener estadísticas generales de proveedores
   */
  async getSuppliersStats(businessId) {
    try {
      const [
        totalSuppliers,
        activeSuppliers,
        totalSpent,
        pendingOrders,
        overdueInvoices
      ] = await Promise.all([
        Supplier.count({ where: { businessId } }),
        Supplier.count({ where: { businessId, status: 'ACTIVE' } }),
        PurchaseOrder.sum('total', { 
          where: { businessId, status: 'RECEIVED' } 
        }),
        PurchaseOrder.count({ 
          where: { 
            businessId, 
            status: { [Op.in]: ['SENT', 'CONFIRMED', 'PARTIALLY_RECEIVED'] } 
          } 
        }),
        SupplierInvoice.count({
          where: {
            businessId,
            dueDate: { [Op.lt]: new Date() },
            status: { [Op.in]: ['PENDING', 'APPROVED'] }
          }
        })
      ]);

      return {
        totalSuppliers: totalSuppliers || 0,
        activeSuppliers: activeSuppliers || 0,
        totalSpent: totalSpent || 0,
        pendingOrders: pendingOrders || 0,
        overdueInvoices: overdueInvoices || 0
      };
    } catch (error) {
      console.error('Error getting suppliers stats:', error);
      throw new Error('Error al obtener estadísticas de proveedores');
    }
  }

  // ================================
  // MÉTODOS AUXILIARES DE PROVEEDORES
  // ================================

  /**
   * Generar código de proveedor
   */
  async generateSupplierCode(businessId, supplierName) {
    try {
      // Usar las primeras 3 letras del nombre del proveedor
      const prefix = supplierName.substring(0, 3).toUpperCase().replace(/[^A-Z]/g, '');
      
      // Obtener el último número usado para este prefijo
      const lastSupplier = await Supplier.findOne({
        where: {
          businessId,
          code: { [Op.like]: `${prefix}%` }
        },
        order: [['code', 'DESC']]
      });

      let nextNumber = 1;
      if (lastSupplier) {
        const lastNumber = parseInt(lastSupplier.code.replace(prefix, '')) || 0;
        nextNumber = lastNumber + 1;
      }

      return `${prefix}${nextNumber.toString().padStart(3, '0')}`;
    } catch (error) {
      // Si hay error, generar código con timestamp
      return `SUP${Date.now().toString().slice(-6)}`;
    }
  }

  /**
   * Generar número de orden de compra
   */
  async generateOrderNumber(businessId) {
    try {
      const year = new Date().getFullYear();
      const prefix = `PO${year}`;
      
      const lastOrder = await PurchaseOrder.findOne({
        where: {
          businessId,
          orderNumber: { [Op.like]: `${prefix}%` }
        },
        order: [['orderNumber', 'DESC']]
      });

      let nextNumber = 1;
      if (lastOrder) {
        const lastNumber = parseInt(lastOrder.orderNumber.replace(prefix, '')) || 0;
        nextNumber = lastNumber + 1;
      }

      return `${prefix}${nextNumber.toString().padStart(4, '0')}`;
    } catch (error) {
      return `PO${Date.now().toString().slice(-6)}`;
    }
  }

  /**
   * Calcular totales de orden
   */
  calculateOrderTotals(items) {
    const subtotal = items.reduce((sum, item) => {
      return sum + (item.quantity * item.unitPrice);
    }, 0);
    
    const tax = subtotal * 0.19; // IVA 19%
    const total = subtotal + tax;
    
    return { subtotal, tax, total };
  }

  // ==================== MÉTODOS AUXILIARES PARA CONFIGURACIONES ====================

  /**
   * Obtener negocio por ID
   */
  async getBusiness(businessId) {
    try {
      return await Business.findByPk(businessId);
    } catch (error) {
      console.error('Error fetching business:', error);
      throw error;
    }
  }

  /**
   * Actualizar configuraciones del negocio
   */
  async updateBusinessSettings(businessId, settings) {
    try {
      const business = await Business.findByPk(businessId);
      if (!business) {
        throw new Error('Negocio no encontrado');
      }

      await business.update({ settings });
      return business;
    } catch (error) {
      console.error('Error updating business settings:', error);
      throw error;
    }
  }
}

module.exports = new BusinessConfigService();