const { PaymentMethod } = require('../models');
const { v4: uuidv4 } = require('uuid');

class PaymentConfigController {
  
  /**
   * Obtener métodos de pago del negocio
   * GET /api/business/:businessId/payment-methods
   */
  static async getPaymentMethods(req, res) {
    try {
      const { businessId } = req.params;
      
      const methods = await PaymentMethod.findAll({
        where: { businessId, isActive: true },
        order: [['order', 'ASC'], ['createdAt', 'ASC']]
      });
      
      return res.json({
        success: true,
        data: methods
      });
    } catch (error) {
      console.error('Error obteniendo métodos de pago:', error);
      return res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }

  /**
   * Obtener TODOS los métodos de pago (activos e inactivos)
   * GET /api/business/:businessId/payment-methods/all
   */
  static async getAllPaymentMethods(req, res) {
    try {
      const { businessId } = req.params;
      
      const methods = await PaymentMethod.findAll({
        where: { businessId },
        order: [['order', 'ASC'], ['createdAt', 'ASC']]
      });
      
      return res.json({
        success: true,
        data: methods
      });
    } catch (error) {
      console.error('Error obteniendo todos los métodos de pago:', error);
      return res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
                accountNumber: '',
                accountType: '',
                holderName: ''
              }
            }
          ]
        });
      }
      
      // Retornar solo métodos activos ordenados
      const methods = (config.paymentMethods || [])
        .filter(m => m.isActive)
        .sort((a, b) => a.order - b.order);
      
      res.json({
        success: true,
        data: methods
      });
      
    } catch (error) {
      console.error('Error obteniendo métodos de pago:', error);
      res.status(500).json({
        success: false,
        error: 'Error al obtener métodos de pago'
      });
    }
  }
  
  /**
   * Obtener todos los métodos (incluidos inactivos) - para administración
   * GET /api/business/:businessId/payment-methods/all
   */
  static async getAllPaymentMethods(req, res) {
    try {
      const { businessId } = req.params;
      
      const config = await BusinessPaymentConfig.findOne({
        where: { businessId }
      });
      
      if (!config) {
        return res.json({
          success: true,
          data: []
        });
      }
      
      const methods = (config.paymentMethods || [])
        .sort((a, b) => a.order - b.order);
      
      res.json({
        success: true,
        data: methods
      });
      
    } catch (error) {
      console.error('Error obteniendo todos los métodos de pago:', error);
      res.status(500).json({
        success: false,
        error: 'Error al obtener métodos de pago'
      });
    }
  }
  
  /**
   * Crear nuevo método de pago
   * POST /api/business/:businessId/payment-methods
   */
  static async createPaymentMethod(req, res) {
    try {
      const { businessId } = req.params;
      const { name, type, requiresProof, icon, bankInfo, metadata } = req.body;
      
      // Validaciones
      if (!name || !type) {
        return res.status(400).json({
          success: false,
          error: 'Nombre y tipo son requeridos'
        });
      }
      
      // Validar tipos permitidos
      const allowedTypes = ['CASH', 'CARD', 'TRANSFER', 'QR', 'ONLINE', 'OTHER'];
      if (!allowedTypes.includes(type)) {
        return res.status(400).json({
          success: false,
          error: `Tipo no válido. Tipos permitidos: ${allowedTypes.join(', ')}`
        });
      }
      
      let config = await BusinessPaymentConfig.findOne({
        where: { businessId }
      });
      
      if (!config) {
        // Crear configuración
        config = await BusinessPaymentConfig.create({
          businessId,
          paymentMethods: []
        });
      }
      
      const methods = config.paymentMethods || [];
      
      // Verificar que no exista un método con el mismo nombre
      const exists = methods.find(m => m.name.toLowerCase() === name.toLowerCase() && m.isActive);
      if (exists) {
        return res.status(400).json({
          success: false,
          error: 'Ya existe un método de pago con ese nombre'
        });
      }
      
      const newMethod = {
        id: uuidv4(),
        name: name.trim(),
        type,
        isActive: true,
        requiresProof: requiresProof || false,
        icon: icon || 'cash-outline',
        order: methods.length + 1,
        bankInfo: bankInfo || null,
        metadata: metadata || {},
        createdAt: new Date().toISOString()
      };
      
      methods.push(newMethod);
      
      await config.update({
        paymentMethods: methods
      });
      
      res.status(201).json({
        success: true,
        data: newMethod,
        message: 'Método de pago creado exitosamente'
      });
      
    } catch (error) {
      console.error('Error creando método de pago:', error);
      res.status(500).json({
        success: false,
        error: 'Error al crear método de pago'
      });
    }
  }
  
  /**
   * Actualizar método de pago
   * PUT /api/business/:businessId/payment-methods/:methodId
   */
  static async updatePaymentMethod(req, res) {
    try {
      const { businessId, methodId } = req.params;
      const updates = req.body;
      
      const config = await BusinessPaymentConfig.findOne({
        where: { businessId }
      });
      
      if (!config) {
        return res.status(404).json({
          success: false,
          error: 'Configuración no encontrada'
        });
      }
      
      const methods = config.paymentMethods || [];
      const methodIndex = methods.findIndex(m => m.id === methodId);
      
      if (methodIndex === -1) {
        return res.status(404).json({
          success: false,
          error: 'Método de pago no encontrado'
        });
      }
      
      // Validar tipo si se está actualizando
      if (updates.type) {
        const allowedTypes = ['CASH', 'CARD', 'TRANSFER', 'QR', 'ONLINE', 'OTHER'];
        if (!allowedTypes.includes(updates.type)) {
          return res.status(400).json({
            success: false,
            error: `Tipo no válido. Tipos permitidos: ${allowedTypes.join(', ')}`
          });
        }
      }
      
      // Actualizar método (preservar campos que no se envían)
      methods[methodIndex] = {
        ...methods[methodIndex],
        ...updates,
        id: methodId, // No permitir cambiar el ID
        updatedAt: new Date().toISOString()
      };
      
      await config.update({
        paymentMethods: methods
      });
      
      res.json({
        success: true,
        data: methods[methodIndex],
        message: 'Método de pago actualizado exitosamente'
      });
      
    } catch (error) {
      console.error('Error actualizando método de pago:', error);
      res.status(500).json({
        success: false,
        error: 'Error al actualizar método de pago'
      });
    }
  }
  
  /**
   * Eliminar (desactivar) método de pago
   * DELETE /api/business/:businessId/payment-methods/:methodId
   */
  static async deletePaymentMethod(req, res) {
    try {
      const { businessId, methodId } = req.params;
      const { hardDelete } = req.query; // Si es true, eliminar permanentemente
      
      const config = await BusinessPaymentConfig.findOne({
        where: { businessId }
      });
      
      if (!config) {
        return res.status(404).json({
          success: false,
          error: 'Configuración no encontrada'
        });
      }
      
      const methods = config.paymentMethods || [];
      
      if (hardDelete === 'true') {
        // Eliminar permanentemente
        const filteredMethods = methods.filter(m => m.id !== methodId);
        
        if (filteredMethods.length === methods.length) {
          return res.status(404).json({
            success: false,
            error: 'Método de pago no encontrado'
          });
        }
        
        await config.update({
          paymentMethods: filteredMethods
        });
        
        return res.json({
          success: true,
          message: 'Método de pago eliminado permanentemente'
        });
      } else {
        // Desactivar (soft delete)
        const methodIndex = methods.findIndex(m => m.id === methodId);
        
        if (methodIndex === -1) {
          return res.status(404).json({
            success: false,
            error: 'Método de pago no encontrado'
          });
        }
        
        methods[methodIndex] = {
          ...methods[methodIndex],
          isActive: false,
          updatedAt: new Date().toISOString()
        };
        
        await config.update({
          paymentMethods: methods
        });
        
        return res.json({
          success: true,
          message: 'Método de pago desactivado exitosamente'
        });
      }
      
    } catch (error) {
      console.error('Error eliminando método de pago:', error);
      res.status(500).json({
        success: false,
        error: 'Error al eliminar método de pago'
      });
    }
  }
  
  /**
   * Activar método de pago
   * POST /api/business/:businessId/payment-methods/:methodId/activate
   */
  static async activatePaymentMethod(req, res) {
    try {
      const { businessId, methodId } = req.params;
      
      const config = await BusinessPaymentConfig.findOne({
        where: { businessId }
      });
      
      if (!config) {
        return res.status(404).json({
          success: false,
          error: 'Configuración no encontrada'
        });
      }
      
      const methods = config.paymentMethods || [];
      const methodIndex = methods.findIndex(m => m.id === methodId);
      
      if (methodIndex === -1) {
        return res.status(404).json({
          success: false,
          error: 'Método de pago no encontrado'
        });
      }
      
      methods[methodIndex] = {
        ...methods[methodIndex],
        isActive: true,
        updatedAt: new Date().toISOString()
      };
      
      await config.update({
        paymentMethods: methods
      });
      
      res.json({
        success: true,
        data: methods[methodIndex],
        message: 'Método de pago activado exitosamente'
      });
      
    } catch (error) {
      console.error('Error activando método de pago:', error);
      res.status(500).json({
        success: false,
        error: 'Error al activar método de pago'
      });
    }
  }
  
  /**
   * Reordenar métodos de pago
   * POST /api/business/:businessId/payment-methods/reorder
   */
  static async reorderPaymentMethods(req, res) {
    try {
      const { businessId } = req.params;
      const { orderedIds } = req.body; // Array de IDs en el nuevo orden
      
      if (!Array.isArray(orderedIds)) {
        return res.status(400).json({
          success: false,
          error: 'Se requiere un array de IDs'
        });
      }
      
      const config = await BusinessPaymentConfig.findOne({
        where: { businessId }
      });
      
      if (!config) {
        return res.status(404).json({
          success: false,
          error: 'Configuración no encontrada'
        });
      }
      
      const methods = config.paymentMethods || [];
      const reorderedMethods = [];
      
      // Primero agregar los métodos en el orden especificado
      orderedIds.forEach((id, index) => {
        const method = methods.find(m => m.id === id);
        if (method) {
          reorderedMethods.push({
            ...method,
            order: index + 1,
            updatedAt: new Date().toISOString()
          });
        }
      });
      
      // Agregar métodos que no están en orderedIds al final
      methods.forEach(method => {
        if (!orderedIds.includes(method.id)) {
          reorderedMethods.push({
            ...method,
            order: reorderedMethods.length + 1
          });
        }
      });
      
      await config.update({
        paymentMethods: reorderedMethods
      });
      
      res.json({
        success: true,
        data: reorderedMethods.sort((a, b) => a.order - b.order),
        message: 'Métodos de pago reordenados exitosamente'
      });
      
    } catch (error) {
      console.error('Error reordenando métodos de pago:', error);
      res.status(500).json({
        success: false,
        error: 'Error al reordenar métodos de pago'
      });
    }
  }
  
}

module.exports = PaymentConfigController;
